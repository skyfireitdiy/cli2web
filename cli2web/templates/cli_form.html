{% extends "base.html" %}

{% block content %}
<div class="container">
    <form onsubmit="executeCommand(event)">
        <div class="command-header">
            <h2>{{ command_name }}</h2>
            <div class="command-line-container">
                <label for="command_line">å®Œæ•´å‘½ä»¤è¡Œ:</label>
                <input type="text" name="command_line" id="command_line"
                       placeholder="ä¾‹å¦‚: docker ps -a" value="{{ command_name }}" readonly>
                <div class="command-hint">å‘½ä»¤è¡Œå°†æ ¹æ®ä¸‹æ–¹é€‰é¡¹è‡ªåŠ¨æ›´æ–°</div>
            </div>
        </div>

        <div class="stdin-container">
            <label for="stdin">æ ‡å‡†è¾“å…¥:</label>
            <textarea name="stdin" id="stdin" rows="4"></textarea>
        </div>
        
        <div class="execute-container">
            <button type="submit" class="execute-btn" id="executeBtn">
                <span class="btn-icon">â–¶</span>
                <span class="btn-text">æ‰§è¡Œ</span>
                <div class="loading-spinner"></div>
            </button>
        </div>

        <div class="output-container">
            <div class="output-header">
                <h3>è¾“å‡º:</h3>
                <button type="button" class="clear-btn" onclick="clearOutput()">
                    <span class="btn-icon">ğŸ—‘ï¸</span>
                    <span class="btn-text">æ¸…é™¤è¾“å‡º</span>
                </button>
            </div>
            <div id="output" class="output"></div>
        </div>

        <div class="options-container">
            <h3>å¸¸ç”¨å‚æ•°:</h3>
            <div class="options-grid">
                {% for option in options %}
                <div class="option-card" data-option="{{ option.name }}">
                    <div class="option-header">
                        <span class="option-name">{{ option.name }}</span>
                        {% if option.long_name %}
                        <span class="option-long-name">({{ option.long_name }})</span>
                        {% endif %}
                        {% if option.is_required %}
                        <span class="required-badge">å¿…å¡«</span>
                        {% endif %}
                    </div>
                    
                    <div class="option-content">
                        <div class="option-description">{{ option.description }}</div>
                        <div class="option-input">
                            {% if option.has_value %}
                                {% if option.value_type == 'textarea' %}
                                <textarea name="{{ option.name }}" id="{{ option.name }}" rows="2"
                                    {% if option.is_required %}required{% endif %}
                                    onchange="updateCommandLine()"></textarea>
                                {% else %}
                                <input type="{{ option.value_type }}" name="{{ option.name }}" id="{{ option.name }}"
                                    {% if option.default_value %}value="{{ option.default_value }}"{% endif %}
                                    {% if option.is_required %}required{% endif %}
                                    oninput="updateCommandLine()">
                                {% endif %}
                            {% else %}
                                <label class="switch">
                                    <input type="checkbox" name="{{ option.name }}" id="{{ option.name }}_checkbox"
                                           onchange="updateCommandLine()">
                                    <span class="slider round"></span>
                                </label>
                            {% endif %}
                        </div>
                    </div>
                </div>
                {% endfor %}
            </div>
        </div>
    </form>
</div>

<style>
    /* æ·»åŠ åˆ°å·²æœ‰çš„æ ·å¼ä¸­ */
    .output {
        background: #2b2b2b;
        color: #f8f8f2;
        padding: 15px;
        border-radius: var(--border-radius);
        font-family: 'Fira Code', monospace;
        margin-top: 10px;
        white-space: pre-wrap;       /* ä¿ç•™ç©ºç™½å’Œæ¢è¡Œ */
        word-wrap: break-word;       /* å…è®¸é•¿è¡Œæ¢è¡Œ */
        overflow-x: auto;            /* æ·»åŠ æ°´å¹³æ»šåŠ¨æ¡ */
        max-height: 500px;           /* é™åˆ¶æœ€å¤§é«˜åº¦ */
        overflow-y: auto;            /* æ·»åŠ å‚ç›´æ»šåŠ¨æ¡ */
        min-height: 100px;           /* æ·»åŠ æœ€å°é«˜åº¦ */
        display: none;               /* åˆå§‹éšè— */
    }

    .output.show {
        display: block !important;
    }

    .error-output {
        color: #ff5555;             /* é”™è¯¯è¾“å‡ºä½¿ç”¨çº¢è‰² */
    }

    /* æ·»åŠ è¾“å‡ºåŠ¨ç”» */
    @keyframes fadeIn {
        from { opacity: 0; transform: translateY(5px); }
        to { opacity: 1; transform: translateY(0); }
    }

    .output div {
        animation: fadeIn 0.2s ease-out;
    }

    /* æ·»åŠ ä¸€äº›é—´è· */
    .options-container {
        margin-top: 30px;
        border-top: 2px solid #eee;
        padding-top: 30px;
    }

    .execute-btn {
        background: var(--primary-color);
        color: white;
        border: none;
        padding: 12px 30px;
        border-radius: var(--border-radius);
        font-size: 16px;
        cursor: pointer;
        transition: all var(--transition-time);
        display: inline-flex;
        align-items: center;
        gap: 8px;
        position: relative;
    }

    .execute-btn:disabled {
        background: #ccc;
        cursor: not-allowed;
        transform: none;
        box-shadow: none;
    }

    .execute-btn.loading {
        padding-right: 50px;
    }

    .execute-btn.loading .loading-spinner {
        display: block;
    }

    .loading-spinner {
        display: none;
        position: absolute;
        right: 15px;
        width: 20px;
        height: 20px;
        border: 2px solid #ffffff;
        border-top: 2px solid transparent;
        border-radius: 50%;
        animation: spin 1s linear infinite;
    }

    @keyframes spin {
        0% { transform: rotate(0deg); }
        100% { transform: rotate(360deg); }
    }

    .execute-btn.loading .btn-text::after {
        content: 'ä¸­...';
    }

    .execute-btn.success {
        background-color: var(--success-color);
    }

    .execute-btn.error {
        background-color: #f44336;
    }

    .execute-btn.loading .btn-text::after {
        content: 'æ‰§è¡Œä¸­...';
    }

    .execute-btn.success .btn-text::after {
        content: ' å®Œæˆ';
    }

    .execute-btn.error .btn-text::after {
        content: ' å¤±è´¥';
    }

    /* æ·»åŠ è¿‡æ¸¡æ•ˆæœ */
    .execute-btn {
        transition: background-color 0.3s ease;
    }

    /* æ·»åŠ å‘½ä»¤åˆ†éš”çº¿æ ·å¼ */
    .command-separator {
        border-top: 2px solid #444;
        margin: 20px 0;
        padding: 10px 0;
        color: #50fa7b;
        font-family: 'Fira Code', monospace;
    }

    /* ç¡®ä¿è¾“å‡ºåŒºåŸŸæ€»æ˜¯å¯è§ */
    .output {
        display: block !important;
        min-height: 200px;
        max-height: 600px;
        overflow-y: auto;
        padding: 15px;
        background: #2b2b2b;
        color: #f8f8f2;
        font-family: 'Fira Code', monospace;
        white-space: pre-wrap;
        word-wrap: break-word;
    }

    /* æ·»åŠ æ»šåŠ¨æ¡æ ·å¼ */
    .output::-webkit-scrollbar {
        width: 8px;
    }

    .output::-webkit-scrollbar-track {
        background: #1a1a1a;
    }

    .output::-webkit-scrollbar-thumb {
        background: #666;
        border-radius: 4px;
    }

    .output::-webkit-scrollbar-thumb:hover {
        background: #888;
    }

    /* è¾“å‡ºåŒºåŸŸæ ‡é¢˜æ æ ·å¼ */
    .output-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 10px;
    }

    /* æ¸…é™¤æŒ‰é’®æ ·å¼ */
    .clear-btn {
        background: #ff4444;
        color: white;
        border: none;
        padding: 8px 16px;
        border-radius: var(--border-radius);
        font-size: 14px;
        cursor: pointer;
        transition: all var(--transition-time);
        display: inline-flex;
        align-items: center;
        gap: 6px;
    }

    .clear-btn:hover {
        background: #ff5555;
        transform: translateY(-1px);
        box-shadow: 0 2px 4px rgba(255, 68, 68, 0.2);
    }

    .clear-btn:active {
        transform: translateY(0);
    }

    .clear-btn .btn-icon {
        font-size: 16px;
    }

    .execution-output {
        margin-bottom: 10px;
        padding: 5px 0;
        border-bottom: 1px solid #444;
    }

    .completion-mark {
        margin-top: 5px;
        padding: 5px;
        color: #4CAF50;
        font-style: italic;
    }

    .error-mark {
        margin-top: 5px;
        padding: 5px;
        color: #f44336;
        font-style: italic;
    }

    .success {
        color: #4CAF50;
    }

    .error {
        color: #f44336;
    }

    .command-separator {
        margin: 10px 0;
        padding: 5px 0;
        border-top: 1px solid #444;
        color: #50fa7b;
        font-family: 'Fira Code', monospace;
    }

    .command-prompt {
        color: #50fa7b;
        font-weight: bold;
    }

    .command-output {
        margin: 5px 0;
        white-space: pre-wrap;
        word-wrap: break-word;
    }
</style>

<script src="https://cdnjs.cloudflare.com/ajax/libs/socket.io/4.0.1/socket.io.js"></script>
<script>
// è°ƒè¯•å‡½æ•°
function debug(message, data = null) {
    const timestamp = new Date().toISOString();
    if (data) {
        console.log(`[${timestamp}] ${message}:`, data);
    } else {
        console.log(`[${timestamp}] ${message}`);
    }
}

// å…¨å±€å˜é‡å®šä¹‰
let currentExecutionId = null;
let socketConnected = false;

// ä»åç«¯ä¼ é€’çš„é€‰é¡¹æ•°æ®è½¬æ¢ä¸ºå‰ç«¯ä½¿ç”¨çš„æ ¼å¼
const commandOptions = {{ options|tojson|safe }}.map(option => ({
    name: option.name,
    long_name: option.long_name,
    description: option.description,
    is_required: option.is_required,
    has_value: option.has_value,
    value_type: option.value_type,
    default_value: option.default_value,
    elementId: option.has_value ? option.name : `${option.name}_checkbox`
}));
debug('Initialized commandOptions', commandOptions);

// åˆå§‹åŒ–Socket.IO
const socket = io({
    transports: ['websocket', 'polling'],
    reconnection: true,
    reconnectionAttempts: 5,
    reconnectionDelay: 1000,
    timeout: 60000
});

// Socket.IO äº‹ä»¶å¤„ç†
socket.on('connect', () => {
    debug('Socket connected');
    socketConnected = true;
});

socket.on('connect_error', (error) => {
    debug('Socket connection error', error);
    socketConnected = false;
});

socket.on('disconnect', () => {
    debug('Socket disconnected');
    socketConnected = false;
});

socket.on('connect_response', (data) => {
    debug('Server connection response', data);
});

// å­˜å‚¨è¾“å‡ºç¼“å†²åŒº
let outputBuffer = new Map();

// å­˜å‚¨å¾…å¤„ç†çš„è¾“å‡º
let pendingOutputs = new Map();

// æ‰§è¡Œå‘½ä»¤
async function executeCommand(event) {
    event.preventDefault();
    debug('Execute command triggered');
    
    if (currentExecutionId) {
        debug('Command already running', currentExecutionId);
        return;
    }
    
    const executeBtn = document.getElementById('executeBtn');
    const outputElement = document.getElementById('output');
    const form = event.target;
    const formData = new FormData(form);
    
    try {
        debug('Starting command execution');
        executeBtn.disabled = true;
        executeBtn.classList.add('loading');
        executeBtn.querySelector('.btn-text').textContent = 'æ‰§è¡Œä¸­';
        
        // ç¬¬ä¸€æ­¥ï¼šå‡†å¤‡æ‰§è¡Œ
        const prepareResponse = await fetch('/prepare', {
            method: 'POST',
            body: formData
        });
        
        const prepareData = await prepareResponse.json();
        if (!prepareData.execution_id) {
            throw new Error('Failed to get execution ID');
        }
        
        currentExecutionId = prepareData.execution_id;
        debug('Command execution prepared', currentExecutionId);
        
        // åˆ›å»ºè¾“å‡ºå®¹å™¨å’Œåˆå§‹åŒ–ç¼“å†²åŒº
        const separator = document.createElement('div');
        separator.className = 'command-separator';
        separator.innerHTML = `<span class="command-prompt">$ ${escapeHtml(formData.get('command_line'))}</span>`;
        outputElement.appendChild(separator);
        
        const outputContainer = document.createElement('div');
        outputContainer.className = 'command-output';
        outputContainer.setAttribute('data-execution-id', currentExecutionId);
        outputElement.appendChild(outputContainer);
        
        outputBuffer.set(currentExecutionId, {
            container: outputContainer,
            content: ''
        });
        
        // ç¡®ä¿è¾“å‡ºåŒºåŸŸå¯è§
        outputElement.style.display = 'block';
        outputElement.classList.add('show');
        
        // ç¬¬äºŒæ­¥ï¼šå¼€å§‹æ‰§è¡Œ
        formData.append('execution_id', currentExecutionId);
        const executeResponse = await fetch('/execute', {
            method: 'POST',
            body: formData
        });
        
        const executeData = await executeResponse.json();
        if (executeData.error) {
            throw new Error(executeData.error);
        }
        
        debug('Command execution started', currentExecutionId);
        
    } catch (error) {
        console.error('Error executing command:', error);
        debug('Error executing command', error);
        
        const errorDiv = document.createElement('div');
        errorDiv.className = 'error-output';
        errorDiv.textContent = `Error: ${error.message}`;
        outputElement.appendChild(errorDiv);
        
        executeBtn.disabled = false;
        executeBtn.classList.remove('loading');
        executeBtn.querySelector('.btn-text').textContent = 'æ‰§è¡Œ';
        currentExecutionId = null;
    }
}

// å¤„ç†å‘½ä»¤è¾“å‡º
socket.on('command_output', function(data) {
    debug('Received output', data);
    
    if (!outputBuffer.has(data.execution_id)) {
        // å¦‚æœç¼“å†²åŒºè¿˜æ²¡å‡†å¤‡å¥½ï¼Œå°†è¾“å‡ºå­˜å‚¨åˆ°å¾…å¤„ç†åˆ—è¡¨
        if (!pendingOutputs.has(data.execution_id)) {
            pendingOutputs.set(data.execution_id, []);
        }
        pendingOutputs.get(data.execution_id).push(data);
        debug('Output queued for later processing', data);
        return;
    }
    
    processOutput(data);
});

// å¤„ç†å•æ¡è¾“å‡º
function processOutput(data) {
    const bufferData = outputBuffer.get(data.execution_id);
    if (!bufferData) {
        debug('No buffer found for execution', data.execution_id);
        return;
    }
    
    // æ·»åŠ æ–°è¾“å‡ºåˆ°ç¼“å†²åŒº
    if (data.pipe === 'stderr') {
        bufferData.content += `<span class="error">${escapeHtml(data.output)}</span>`;
    } else {
        bufferData.content += escapeHtml(data.output);
    }
    
    // æ›´æ–°è¾“å‡ºå®¹å™¨
    bufferData.container.innerHTML = bufferData.content;
    
    // æ»šåŠ¨åˆ°åº•éƒ¨
    const outputElement = document.getElementById('output');
    outputElement.scrollTop = outputElement.scrollHeight;
}

// å¤„ç†å‘½ä»¤å®Œæˆ
socket.on('command_complete', function(data) {
    debug('Command complete', data);
    const outputElement = document.getElementById('output');
    const executeBtn = document.getElementById('executeBtn');
    
    // å¤„ç†å¾…å¤„ç†çš„è¾“å‡º
    if (pendingOutputs.has(data.execution_id)) {
        const outputs = pendingOutputs.get(data.execution_id);
        outputs.forEach(output => processOutput(output));
        pendingOutputs.delete(data.execution_id);
    }
    
    // æ·»åŠ å®Œæˆæ ‡è®°
    const bufferData = outputBuffer.get(data.execution_id);
    if (bufferData) {
        const completionMark = document.createElement('div');
        completionMark.className = 'completion-mark';
        completionMark.innerHTML = `<span class="success">âœ“ å‘½ä»¤æ‰§è¡Œå®Œæˆ (è¿”å›ç : ${data.return_code})</span>`;
        bufferData.container.appendChild(completionMark);
        
        // æ¸…ç†ç¼“å†²åŒº
        outputBuffer.delete(data.execution_id);
    }
    
    // é‡ç½®çŠ¶æ€
    executeBtn.disabled = false;
    executeBtn.classList.remove('loading');
    executeBtn.querySelector('.btn-text').textContent = 'æ‰§è¡Œ';
    
    // é‡è¦ï¼šæ¸…ç†å½“å‰æ‰§è¡ŒID
    if (currentExecutionId === data.execution_id) {
        currentExecutionId = null;
    }
    
    // æ»šåŠ¨åˆ°åº•éƒ¨
    outputElement.scrollTop = outputElement.scrollHeight;
});

// å¤„ç†å‘½ä»¤é”™è¯¯
socket.on('command_error', function(data) {
    debug('Command error', data);
    const outputElement = document.getElementById('output');
    const executeBtn = document.getElementById('executeBtn');
    
    // å¤„ç†å¾…å¤„ç†çš„è¾“å‡º
    if (pendingOutputs.has(data.execution_id)) {
        const outputs = pendingOutputs.get(data.execution_id);
        outputs.forEach(output => processOutput(output));
        pendingOutputs.delete(data.execution_id);
    }
    
    // æ·»åŠ é”™è¯¯æ ‡è®°
    const bufferData = outputBuffer.get(data.execution_id);
    if (bufferData) {
        const errorMark = document.createElement('div');
        errorMark.className = 'error-mark';
        errorMark.innerHTML = `<span class="error">âœ— å‘½ä»¤æ‰§è¡Œé”™è¯¯: ${escapeHtml(data.error)}</span>`;
        bufferData.container.appendChild(errorMark);
        
        // æ¸…ç†ç¼“å†²åŒº
        outputBuffer.delete(data.execution_id);
    }
    
    // é‡ç½®çŠ¶æ€
    executeBtn.disabled = false;
    executeBtn.classList.remove('loading');
    executeBtn.querySelector('.btn-text').textContent = 'æ‰§è¡Œ';
    
    // é‡è¦ï¼šæ¸…ç†å½“å‰æ‰§è¡ŒID
    if (currentExecutionId === data.execution_id) {
        currentExecutionId = null;
    }
    
    // æ»šåŠ¨åˆ°åº•éƒ¨
    outputElement.scrollTop = outputElement.scrollHeight;
});

// HTMLè½¬ä¹‰å‡½æ•°
function escapeHtml(unsafe) {
    return unsafe
        .replace(/&/g, "&amp;")
        .replace(/</g, "&lt;")
        .replace(/>/g, "&gt;")
        .replace(/"/g, "&quot;")
        .replace(/'/g, "&#039;");
}

// é¡µé¢åŠ è½½æ—¶åˆå§‹åŒ–
document.addEventListener('DOMContentLoaded', function() {
    updateCommandLine();
});

function updateCommandLine() {
    try {
        debug('Updating command line');
        const commandInput = document.getElementById('command_line');
        const baseCommand = '{{ command_name }}';
        const args = new Set();
        
        // éå†æ‰€æœ‰é€‰é¡¹
        commandOptions.forEach(option => {
            debug('Processing option', option);
            // ä½¿ç”¨é€‰é¡¹ä¸­å®šä¹‰çš„elementId
            const elementId = option.elementId;
            
            debug('Looking for element with ID', elementId);
            const element = document.getElementById(elementId);
            
            if (element) {
                debug('Found element', element);
                if (option.has_value) {
                    // å¤„ç†æœ‰å€¼çš„é€‰é¡¹
                    if (element.value) {
                        args.add(`${option.name} ${element.value}`);
                        debug('Added value option', `${option.name} ${element.value}`);
                    }
                } else {
                    // å¤„ç†å¤é€‰æ¡†é€‰é¡¹
                    if (element.checked) {
                        args.add(option.name);
                        debug('Added flag option', option.name);
                        // æ›´æ–°é€‰é¡¹å¡æ ·å¼
                        const optionCard = document.querySelector(`[data-option="${option.name}"]`);
                        if (optionCard) {
                            optionCard.classList.add('active');
                            debug('Activated option card', option.name);
                        }
                    } else {
                        // ç§»é™¤é€‰é¡¹å¡æ ·å¼
                        const optionCard = document.querySelector(`[data-option="${option.name}"]`);
                        if (optionCard) {
                            optionCard.classList.remove('active');
                            debug('Deactivated option card', option.name);
                        }
                    }
                }
            } else {
                debug('Element not found for option', { elementId, option });
            }
        });
        
        // æ›´æ–°å‘½ä»¤è¡Œè¾“å…¥æ¡†
        const commandLine = [baseCommand, ...args].join(' ');
        debug('Updated command line', commandLine);
        commandInput.value = commandLine;
        
        // æ·»åŠ æ›´æ–°åŠ¨ç”»
        commandInput.classList.add('updated');
        setTimeout(() => commandInput.classList.remove('updated'), 300);
        
    } catch (error) {
        console.error('Error updating command line:', error);
        debug('Error updating command line', error);
    }
}

// æ·»åŠ å‘½ä»¤è¡Œè¾“å…¥æ¡†çš„ç›´æ¥ç¼–è¾‘æ”¯æŒ
document.getElementById('command_line').addEventListener('input', function(event) {
    const commandInput = event.target;
    commandInput.classList.add('updated');
    setTimeout(() => commandInput.classList.remove('updated'), 300);
});

// ç§»é™¤å‘½ä»¤è¡Œè¾“å…¥æ¡†çš„åªè¯»å±æ€§
document.getElementById('command_line').removeAttribute('readonly');

// ä¸ºæ‰€æœ‰é€‰é¡¹æ·»åŠ äº‹ï¿½ï¿½ç›‘å¬å™¨
document.addEventListener('DOMContentLoaded', function() {
    debug('Setting up option event listeners');
    commandOptions.forEach(option => {
        // ä½¿ç”¨é€‰é¡¹ä¸­å®šä¹‰çš„elementId
        const elementId = option.elementId;
        
        const element = document.getElementById(elementId);
        if (element) {
            debug('Adding event listener to', elementId);
            if (option.has_value) {
                element.addEventListener('input', updateCommandLine);
            } else {
                element.addEventListener('change', updateCommandLine);
            }
        } else {
            debug('Element not found for', elementId);
        }
    });
    
    // åˆå§‹æ›´æ–°å‘½ä»¤è¡Œ
    updateCommandLine();
});

// æ·»åŠ æ¸…é™¤è¾“å‡ºå‡½æ•°
function clearOutput() {
    const outputElement = document.getElementById('output');
    if (outputElement) {
        // æ·»åŠ æ·¡å‡ºåŠ¨ç”»
        outputElement.style.opacity = '0';
        outputElement.style.transform = 'translateY(10px)';
        
        // ç­‰å¾…åŠ¨ç”»å®Œæˆåæ¸…ç©ºå†…å®¹
        setTimeout(() => {
            outputElement.textContent = '';
            // é‡ç½®æ ·å¼
            outputElement.style.opacity = '1';
            outputElement.style.transform = 'translateY(0)';
        }, 300);
        
        debug('Output cleared');
    }
}
</script>
{% endblock %} 